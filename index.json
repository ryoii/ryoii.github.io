[{"categories":null,"content":"网页抓包 通过网页 F12 抓包可以发现，几乎所有的网易云接口都发向同一个接口 [POST] https://music.163.com/weapi/cloudsearch/get/web?csrf_token= 其中携带了两个请求参数 params 和 encSecKey。通过请求回放可以成功返回，说明请求没有一次性过期的参数。将请求参数复制到 API 调试工具也能成功返回，说明不需要特殊请求头。 因此，开始分析 params 和 encSecKey 的构造。 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:1:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#网页抓包"},{"categories":null,"content":"js 检索 在 Chrome 的调试中全局检索(Ctrl + Shift + F) 关键字 encSecKey，可以发现这个变量只在 core_{hash}.js 文件中出现过两次。 其中一次如下，这里一大段都是请求路径、请求参数匹配，url 替换等逻辑，抛去这些代码后，关键的地方就几行。很明显，这里就是生成两个请求参数的地方了，并把参数放到请求的 data 里。 // ... var bKB6v = window.asrsea(JSON.stringify(i4m), buV4Z([\"流泪\", \"强\"]), buV4Z(Rg0x.md), buV4Z([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); e4i.data = j4n.cr5w({ params: bKB6v.encText, encSecKey: bKB6v.encSecKey }) // ... 这里出现了 encSecKey，是 bkB6v 变量的一个属性。那可以推断，另一次出现 encSecKey 应该就是构造 bkB6v 对象的方法了（后续分析结果也确实如此）。 这里由 3 个地方值得注意。i4m, buV4z, window.asrsea。我们依次分析。 不同版本的 core.js 可能混淆出来的变量名并不相同 i4m 通过上下文可以发现 i4m 通过 url 的 path, query, body 等地方进行判断生成的，很可能就是实际的请求参数。我们打下断点，最终得到了 i4m 变量的值。 { \"hlpretag\":\"\u003cspan class=\\\"s-fc7\\\"\u003e\", \"hlposttag\":\"\u003c/span\u003e\", \"id\":\"19723756\", \"s\":\"daddydaddydo\", \"type\":\"1\", \"offset\":\"0\", \"total\":\"true\", \"limit\":\"30\", \"csrf_token\":\"\" } 完美。这里就是歌曲搜索接口可能的参数，包括关键字、分页。可以推断，后续通过 JSON.stringify(i4m) 序列化成字符串后进行了加密。 buV4z core.js 中搜索这个变量可以找到这是一个 function var buV4Z = function(chL0x) { var m4q = []; j4n.bg4k(chL0x, function(chE0x) { m4q.push(Rg0x.emj[chE0x]) }); return m4q.join(\"\") }; 可以猜测，这里表示 foreach, 遍历 chL0x 并通过 Rg0x.emj 映射后拼接成字符串。找到 Rg0x.emj 确实是一个 map Rg0x.emj = { \"色\": \"00e0b\", \"流感\": \"509f6\", \"这边\": \"259df\", \"弱\": \"8642d\", \"嘴唇\": \"bc356\", \"亲\": \"62901\", \"开心\": \"477df\", \"呲牙\": \"22677\", \"憨笑\": \"ec152\", // ...... } 通过在 console 或者 nodejs 等环境执行下这个代码，可以得到 window.asrsea 的几个实际参数 // 010001 // 00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 // 0CoJUm6Qyw8W8jud window.asrsea(JSON.stringify(i4m), buV4Z([\"流泪\", \"强\"]), buV4Z(Rg0x.md), buV4Z([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); window.asrsea 全局搜索 window.asrsea 发现只有一个地方有定义 function a(a) { var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\"; for (d = 0; a \u003e d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c } function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\") , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,\"\",c), e = encryptedString(d, a) } function d(d, e, f, g) { var h = {} , i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h } function e(a, b, d, e) { var f = {}; return f.encText = c(a + e, b, d), f } window.asrsea = d, window.ecnonasr = e window.asrsea 也就是 d 方法。这里的核心也是 d 方法，在 d 方法中生成了 encText 即 params 和 encSecKey。 a, b, c 方法都是被 d 方法调用的。 可以简易分析下，a 方法是一个随机数生成方法，b 方法是 AES 加密方法, c 方法是 RSA 加密方法。d 方法生成一个随机数，并通过 3 此加密分别生成 encText 和 encSecKey。 结合前文提到的 window.asrsea 的参数，可以得到 function d(json, k1, k2, k3) { var r = random() var encText = AES(AES(json, k3), r) var encSecKey = RSA(r, k1, k2) } 至此，请求参数的生成逻辑已经很明确了。但是，我们还需要找到加密的逻辑。虽然 AES 和 RSA 都是常用的加密算法，但是也有参数需要配置，而加密方法可可能会自行实现。 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:2:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#js-检索"},{"categories":null,"content":"js 检索 在 Chrome 的调试中全局检索(Ctrl + Shift + F) 关键字 encSecKey，可以发现这个变量只在 core_{hash}.js 文件中出现过两次。 其中一次如下，这里一大段都是请求路径、请求参数匹配，url 替换等逻辑，抛去这些代码后，关键的地方就几行。很明显，这里就是生成两个请求参数的地方了，并把参数放到请求的 data 里。 // ... var bKB6v = window.asrsea(JSON.stringify(i4m), buV4Z([\"流泪\", \"强\"]), buV4Z(Rg0x.md), buV4Z([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); e4i.data = j4n.cr5w({ params: bKB6v.encText, encSecKey: bKB6v.encSecKey }) // ... 这里出现了 encSecKey，是 bkB6v 变量的一个属性。那可以推断，另一次出现 encSecKey 应该就是构造 bkB6v 对象的方法了（后续分析结果也确实如此）。 这里由 3 个地方值得注意。i4m, buV4z, window.asrsea。我们依次分析。 不同版本的 core.js 可能混淆出来的变量名并不相同 i4m 通过上下文可以发现 i4m 通过 url 的 path, query, body 等地方进行判断生成的，很可能就是实际的请求参数。我们打下断点，最终得到了 i4m 变量的值。 { \"hlpretag\":\"\", \"hlposttag\":\"\", \"id\":\"19723756\", \"s\":\"daddydaddydo\", \"type\":\"1\", \"offset\":\"0\", \"total\":\"true\", \"limit\":\"30\", \"csrf_token\":\"\" } 完美。这里就是歌曲搜索接口可能的参数，包括关键字、分页。可以推断，后续通过 JSON.stringify(i4m) 序列化成字符串后进行了加密。 buV4z core.js 中搜索这个变量可以找到这是一个 function var buV4Z = function(chL0x) { var m4q = []; j4n.bg4k(chL0x, function(chE0x) { m4q.push(Rg0x.emj[chE0x]) }); return m4q.join(\"\") }; 可以猜测，这里表示 foreach, 遍历 chL0x 并通过 Rg0x.emj 映射后拼接成字符串。找到 Rg0x.emj 确实是一个 map Rg0x.emj = { \"色\": \"00e0b\", \"流感\": \"509f6\", \"这边\": \"259df\", \"弱\": \"8642d\", \"嘴唇\": \"bc356\", \"亲\": \"62901\", \"开心\": \"477df\", \"呲牙\": \"22677\", \"憨笑\": \"ec152\", // ...... } 通过在 console 或者 nodejs 等环境执行下这个代码，可以得到 window.asrsea 的几个实际参数 // 010001 // 00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 // 0CoJUm6Qyw8W8jud window.asrsea(JSON.stringify(i4m), buV4Z([\"流泪\", \"强\"]), buV4Z(Rg0x.md), buV4Z([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); window.asrsea 全局搜索 window.asrsea 发现只有一个地方有定义 function a(a) { var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\"; for (d = 0; a \u003e d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c } function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\") , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,\"\",c), e = encryptedString(d, a) } function d(d, e, f, g) { var h = {} , i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h } function e(a, b, d, e) { var f = {}; return f.encText = c(a + e, b, d), f } window.asrsea = d, window.ecnonasr = e window.asrsea 也就是 d 方法。这里的核心也是 d 方法，在 d 方法中生成了 encText 即 params 和 encSecKey。 a, b, c 方法都是被 d 方法调用的。 可以简易分析下，a 方法是一个随机数生成方法，b 方法是 AES 加密方法, c 方法是 RSA 加密方法。d 方法生成一个随机数，并通过 3 此加密分别生成 encText 和 encSecKey。 结合前文提到的 window.asrsea 的参数，可以得到 function d(json, k1, k2, k3) { var r = random() var encText = AES(AES(json, k3), r) var encSecKey = RSA(r, k1, k2) } 至此，请求参数的生成逻辑已经很明确了。但是，我们还需要找到加密的逻辑。虽然 AES 和 RSA 都是常用的加密算法，但是也有参数需要配置，而加密方法可可能会自行实现。 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:2:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#i4m"},{"categories":null,"content":"js 检索 在 Chrome 的调试中全局检索(Ctrl + Shift + F) 关键字 encSecKey，可以发现这个变量只在 core_{hash}.js 文件中出现过两次。 其中一次如下，这里一大段都是请求路径、请求参数匹配，url 替换等逻辑，抛去这些代码后，关键的地方就几行。很明显，这里就是生成两个请求参数的地方了，并把参数放到请求的 data 里。 // ... var bKB6v = window.asrsea(JSON.stringify(i4m), buV4Z([\"流泪\", \"强\"]), buV4Z(Rg0x.md), buV4Z([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); e4i.data = j4n.cr5w({ params: bKB6v.encText, encSecKey: bKB6v.encSecKey }) // ... 这里出现了 encSecKey，是 bkB6v 变量的一个属性。那可以推断，另一次出现 encSecKey 应该就是构造 bkB6v 对象的方法了（后续分析结果也确实如此）。 这里由 3 个地方值得注意。i4m, buV4z, window.asrsea。我们依次分析。 不同版本的 core.js 可能混淆出来的变量名并不相同 i4m 通过上下文可以发现 i4m 通过 url 的 path, query, body 等地方进行判断生成的，很可能就是实际的请求参数。我们打下断点，最终得到了 i4m 变量的值。 { \"hlpretag\":\"\", \"hlposttag\":\"\", \"id\":\"19723756\", \"s\":\"daddydaddydo\", \"type\":\"1\", \"offset\":\"0\", \"total\":\"true\", \"limit\":\"30\", \"csrf_token\":\"\" } 完美。这里就是歌曲搜索接口可能的参数，包括关键字、分页。可以推断，后续通过 JSON.stringify(i4m) 序列化成字符串后进行了加密。 buV4z core.js 中搜索这个变量可以找到这是一个 function var buV4Z = function(chL0x) { var m4q = []; j4n.bg4k(chL0x, function(chE0x) { m4q.push(Rg0x.emj[chE0x]) }); return m4q.join(\"\") }; 可以猜测，这里表示 foreach, 遍历 chL0x 并通过 Rg0x.emj 映射后拼接成字符串。找到 Rg0x.emj 确实是一个 map Rg0x.emj = { \"色\": \"00e0b\", \"流感\": \"509f6\", \"这边\": \"259df\", \"弱\": \"8642d\", \"嘴唇\": \"bc356\", \"亲\": \"62901\", \"开心\": \"477df\", \"呲牙\": \"22677\", \"憨笑\": \"ec152\", // ...... } 通过在 console 或者 nodejs 等环境执行下这个代码，可以得到 window.asrsea 的几个实际参数 // 010001 // 00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 // 0CoJUm6Qyw8W8jud window.asrsea(JSON.stringify(i4m), buV4Z([\"流泪\", \"强\"]), buV4Z(Rg0x.md), buV4Z([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); window.asrsea 全局搜索 window.asrsea 发现只有一个地方有定义 function a(a) { var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\"; for (d = 0; a \u003e d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c } function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\") , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,\"\",c), e = encryptedString(d, a) } function d(d, e, f, g) { var h = {} , i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h } function e(a, b, d, e) { var f = {}; return f.encText = c(a + e, b, d), f } window.asrsea = d, window.ecnonasr = e window.asrsea 也就是 d 方法。这里的核心也是 d 方法，在 d 方法中生成了 encText 即 params 和 encSecKey。 a, b, c 方法都是被 d 方法调用的。 可以简易分析下，a 方法是一个随机数生成方法，b 方法是 AES 加密方法, c 方法是 RSA 加密方法。d 方法生成一个随机数，并通过 3 此加密分别生成 encText 和 encSecKey。 结合前文提到的 window.asrsea 的参数，可以得到 function d(json, k1, k2, k3) { var r = random() var encText = AES(AES(json, k3), r) var encSecKey = RSA(r, k1, k2) } 至此，请求参数的生成逻辑已经很明确了。但是，我们还需要找到加密的逻辑。虽然 AES 和 RSA 都是常用的加密算法，但是也有参数需要配置，而加密方法可可能会自行实现。 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:2:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#buv4z"},{"categories":null,"content":"js 检索 在 Chrome 的调试中全局检索(Ctrl + Shift + F) 关键字 encSecKey，可以发现这个变量只在 core_{hash}.js 文件中出现过两次。 其中一次如下，这里一大段都是请求路径、请求参数匹配，url 替换等逻辑，抛去这些代码后，关键的地方就几行。很明显，这里就是生成两个请求参数的地方了，并把参数放到请求的 data 里。 // ... var bKB6v = window.asrsea(JSON.stringify(i4m), buV4Z([\"流泪\", \"强\"]), buV4Z(Rg0x.md), buV4Z([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); e4i.data = j4n.cr5w({ params: bKB6v.encText, encSecKey: bKB6v.encSecKey }) // ... 这里出现了 encSecKey，是 bkB6v 变量的一个属性。那可以推断，另一次出现 encSecKey 应该就是构造 bkB6v 对象的方法了（后续分析结果也确实如此）。 这里由 3 个地方值得注意。i4m, buV4z, window.asrsea。我们依次分析。 不同版本的 core.js 可能混淆出来的变量名并不相同 i4m 通过上下文可以发现 i4m 通过 url 的 path, query, body 等地方进行判断生成的，很可能就是实际的请求参数。我们打下断点，最终得到了 i4m 变量的值。 { \"hlpretag\":\"\", \"hlposttag\":\"\", \"id\":\"19723756\", \"s\":\"daddydaddydo\", \"type\":\"1\", \"offset\":\"0\", \"total\":\"true\", \"limit\":\"30\", \"csrf_token\":\"\" } 完美。这里就是歌曲搜索接口可能的参数，包括关键字、分页。可以推断，后续通过 JSON.stringify(i4m) 序列化成字符串后进行了加密。 buV4z core.js 中搜索这个变量可以找到这是一个 function var buV4Z = function(chL0x) { var m4q = []; j4n.bg4k(chL0x, function(chE0x) { m4q.push(Rg0x.emj[chE0x]) }); return m4q.join(\"\") }; 可以猜测，这里表示 foreach, 遍历 chL0x 并通过 Rg0x.emj 映射后拼接成字符串。找到 Rg0x.emj 确实是一个 map Rg0x.emj = { \"色\": \"00e0b\", \"流感\": \"509f6\", \"这边\": \"259df\", \"弱\": \"8642d\", \"嘴唇\": \"bc356\", \"亲\": \"62901\", \"开心\": \"477df\", \"呲牙\": \"22677\", \"憨笑\": \"ec152\", // ...... } 通过在 console 或者 nodejs 等环境执行下这个代码，可以得到 window.asrsea 的几个实际参数 // 010001 // 00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7 // 0CoJUm6Qyw8W8jud window.asrsea(JSON.stringify(i4m), buV4Z([\"流泪\", \"强\"]), buV4Z(Rg0x.md), buV4Z([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); window.asrsea 全局搜索 window.asrsea 发现只有一个地方有定义 function a(a) { var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\"; for (d = 0; a \u003e d; d += 1) e = Math.random() * b.length, e = Math.floor(e), c += b.charAt(e); return c } function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\") , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,\"\",c), e = encryptedString(d, a) } function d(d, e, f, g) { var h = {} , i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h } function e(a, b, d, e) { var f = {}; return f.encText = c(a + e, b, d), f } window.asrsea = d, window.ecnonasr = e window.asrsea 也就是 d 方法。这里的核心也是 d 方法，在 d 方法中生成了 encText 即 params 和 encSecKey。 a, b, c 方法都是被 d 方法调用的。 可以简易分析下，a 方法是一个随机数生成方法，b 方法是 AES 加密方法, c 方法是 RSA 加密方法。d 方法生成一个随机数，并通过 3 此加密分别生成 encText 和 encSecKey。 结合前文提到的 window.asrsea 的参数，可以得到 function d(json, k1, k2, k3) { var r = random() var encText = AES(AES(json, k3), r) var encSecKey = RSA(r, k1, k2) } 至此，请求参数的生成逻辑已经很明确了。但是，我们还需要找到加密的逻辑。虽然 AES 和 RSA 都是常用的加密算法，但是也有参数需要配置，而加密方法可可能会自行实现。 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:2:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#windowasrsea"},{"categories":null,"content":"寻找一组可用参数 我们需要找到一组可以供我们后续测试加密代码的参数，通过 console 的 debug 功能找到以下参数 var json = \"{\\\"hlpretag\\\":\\\"\u003cspan class=\\\\\\\"s-fc7\\\\\\\"\u003e\\\",\\\"hlposttag\\\":\\\"\u003c/span\u003e\\\",\\\"id\\\":\\\"19723756\\\",\\\"s\\\":\\\"daddydaddydo\\\",\\\"type\\\":\\\"1\\\",\\\"offset\\\":\\\"0\\\",\\\"total\\\":\\\"true\\\",\\\"limit\\\":\\\"30\\\",\\\"csrf_token\\\":\\\"\\\"}\" var k1 = \"010001\" var k2 = \"00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7\" var k3 = \"0CoJUm6Qyw8W8jud\" var random = \"29MLTcVbKsvktpRV\" // 输出结果 var params = \"fS15fDwPSPzRvd8OYwEnU2P/l/11+QKvMzWEy/EOn2RpIFXFYuDnEJrioOK25vaUCKckA2MPliSOq6gT5DtWQvEYq15QPvzphiPEUrd8Oj+UhTvOAfRE8v8gyrc8Ik5w6RyqosC3SqapEgPTagS0+l6yxhgwz8sWhL9yMn3SpgCJcnQ94YdKbxXVwpwXrO54HLHJSwzhKRECVsPU4rU+dvMbP2Z2x6HHUlOC3WYWdGkaj7h3PYivOKq3/yPgKyp9uExonxdn6aSAR46v5NSRk+6g+fqt9hR/UuKDXtKXVtbBGOFUbb/8Ns+m4Hj7k1Js\" var encSecKey = \"c04eb0eddbafdf8dc6d2b322d4d9c32dc2dbfe8a21711c6196cd4ee134e0ef5ca781a198c7e33970b1e620abb594f03a011e40b2a690c830be4644c0adbb4337cb12d003236f04697eeff1a503e834eeb7ac06ef845786a430d19472a0c88eda5719492b586aba0d59acbee60315f0e91a205cc98eeb58d189d562dd2b74c5a5\" 也就说，我们要找到能正确输出结果的 AES 和 RSA 算法即可 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:3:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#寻找一组可用参数"},{"categories":null,"content":"实际调试 我们把 core 中的关键代码拷贝出来，并手动调用 d 方法来验证我们的结果。这里需要把生成随机数的方法改成返回我们 debug 获取到的随机数。避免调试 js 的时候每次结果都不一样。 function a(a) { // var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\"; // for (d = 0; a \u003e d; d += 1) // e = Math.random() * b.length, // e = Math.floor(e), // c += b.charAt(e); // return c return \"29MLTcVbKsvktpRV\" } function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\") , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,\"\",c), e = encryptedString(d, a) } function d(d, e, f, g) { var h = {} , i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h } console.log(d(json, k1, k2, k3)) 执行后报错是必然了，这么大个 js 文件怎么可以只有这点内容。我们一个个把缺失的函数补上。在补的过程中留意一些共同特征 CryptoJS 是实现在 core.js 里的加密库，AES, RSA 加密都挂载在这个对象下面 biXXXXX 方法都是 BigInt 相关的方法，参与大数计算，主要是在 RSA 中使用 这里提供一份补充完整的代码 var CryptoJS = CryptoJS || function (u, p) { var d = {}, l = d.lib = {}, s = function () { }, t = l.Base = { extend: function (a) { s.prototype = this; var c = new s; a \u0026\u0026 c.mixIn(a); c.hasOwnProperty(\"init\") || (c.init = function () { c.$super.init.apply(this, arguments) }); c.init.prototype = c; c.$super = this; return c }, create: function () { var a = this.extend(); a.init.apply(a, arguments); return a }, init: function () { }, mixIn: function (a) { for (var c in a) a.hasOwnProperty(c) \u0026\u0026 (this[c] = a[c]); a.hasOwnProperty(\"toString\") \u0026\u0026 (this.toString = a.toString) }, clone: function () { return this.init.prototype.extend(this) } }, r = l.WordArray = t.extend({ init: function (a, c) { a = this.words = a || []; this.sigBytes = c != p ? c : 4 * a.length }, toString: function (a) { return (a || v).stringify(this) }, concat: function (a) { var c = this.words, e = a.words, j = this.sigBytes; a = a.sigBytes; this.clamp(); if (j % 4) for (var k = 0; k \u003c a; k++) c[j + k \u003e\u003e\u003e 2] |= (e[k \u003e\u003e\u003e 2] \u003e\u003e\u003e 24 - 8 * (k % 4) \u0026 255) \u003c\u003c 24 - 8 * ((j + k) % 4); else if (65535 \u003c e.length) for (k = 0; k \u003c a; k += 4) c[j + k \u003e\u003e\u003e 2] = e[k \u003e\u003e\u003e 2]; else c.push.apply(c, e); this.sigBytes += a; return this }, clamp: function () { var a = this.words, c = this.sigBytes; a[c \u003e\u003e\u003e 2] \u0026= 4294967295 \u003c\u003c 32 - 8 * (c % 4); a.length = u.ceil(c / 4) }, clone: function () { var a = t.clone.call(this); a.words = this.words.slice(0); return a }, random: function (a) { for (var c = [], e = 0; e \u003c a; e += 4) c.push(4294967296 * u.random() | 0); return new r.init(c, a) } }), w = d.enc = {}, v = w.Hex = { stringify: function (a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j \u003c a; j++) { var k = c[j \u003e\u003e\u003e 2] \u003e\u003e\u003e 24 - 8 * (j % 4) \u0026 255; e.push((k \u003e\u003e\u003e 4).toString(16)); e.push((k \u0026 15).toString(16)) } return e.join(\"\") }, parse: function (a) { for (var c = a.length, e = [], j = 0; j \u003c c; j += 2) e[j \u003e\u003e\u003e 3] |= parseInt(a.substr(j, 2), 16) \u003c\u003c 24 - 4 * (j % 8); return new r.init(e, c / 2) } }, b = w.Latin1 = { stringify: function (a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j \u003c a; j++) e.push(String.fromCharCode(c[j \u003e\u003e\u003e 2] \u003e\u003e\u003e 24 - 8 * (j % 4) \u0026 255)); return e.join(\"\") }, parse: function (a) { for (var c = a.length, e = [], j = 0; j \u003c c; j++) e[j \u003e\u003e\u003e 2] |= (a.charCodeAt(j) \u0026 255) \u003c\u003c 24 - 8 * (j % 4); return new r.init(e, c) } }, x = w.Utf8 = { stringify: function (a) { try { return decodeURIComponent(escape(b.stringify(a))) } catch (c) { throw Error(\"Malformed UTF-8 data\") } }, parse: function (a) { return b.parse(unescape(encodeURIComponent(a))) } }, q = l.BufferedBlockAlgorithm = t.extend({ reset: function () { this.i0x = new r.init; this.yx9o = 0 }, zU9L: function (a) { \"string\" == typeof a \u0026\u0026 (a = x.parse(a)); this.i0x.concat(a); this.yx9o += a.sigBytes }, mU5Z: function (a) { var c = this.i0x, e = c.words, j = c.sigBytes, k = this.blockSize, b = j / (4 * k), b = a ? u.ceil(b) : u.max((b | 0) - this.WX9O, 0); a = b * k; j = u.min(","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:4:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#实际调试"},{"categories":null,"content":"实际调试 我们把 core 中的关键代码拷贝出来，并手动调用 d 方法来验证我们的结果。这里需要把生成随机数的方法改成返回我们 debug 获取到的随机数。避免调试 js 的时候每次结果都不一样。 function a(a) { // var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\"; // for (d = 0; a \u003e d; d += 1) // e = Math.random() * b.length, // e = Math.floor(e), // c += b.charAt(e); // return c return \"29MLTcVbKsvktpRV\" } function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b) , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\") , e = CryptoJS.enc.Utf8.parse(a) , f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,\"\",c), e = encryptedString(d, a) } function d(d, e, f, g) { var h = {} , i = a(16); return h.encText = b(d, g), h.encText = b(h.encText, i), h.encSecKey = c(i, e, f), h } console.log(d(json, k1, k2, k3)) 执行后报错是必然了，这么大个 js 文件怎么可以只有这点内容。我们一个个把缺失的函数补上。在补的过程中留意一些共同特征 CryptoJS 是实现在 core.js 里的加密库，AES, RSA 加密都挂载在这个对象下面 biXXXXX 方法都是 BigInt 相关的方法，参与大数计算，主要是在 RSA 中使用 这里提供一份补充完整的代码 var CryptoJS = CryptoJS || function (u, p) { var d = {}, l = d.lib = {}, s = function () { }, t = l.Base = { extend: function (a) { s.prototype = this; var c = new s; a \u0026\u0026 c.mixIn(a); c.hasOwnProperty(\"init\") || (c.init = function () { c.$super.init.apply(this, arguments) }); c.init.prototype = c; c.$super = this; return c }, create: function () { var a = this.extend(); a.init.apply(a, arguments); return a }, init: function () { }, mixIn: function (a) { for (var c in a) a.hasOwnProperty(c) \u0026\u0026 (this[c] = a[c]); a.hasOwnProperty(\"toString\") \u0026\u0026 (this.toString = a.toString) }, clone: function () { return this.init.prototype.extend(this) } }, r = l.WordArray = t.extend({ init: function (a, c) { a = this.words = a || []; this.sigBytes = c != p ? c : 4 * a.length }, toString: function (a) { return (a || v).stringify(this) }, concat: function (a) { var c = this.words, e = a.words, j = this.sigBytes; a = a.sigBytes; this.clamp(); if (j % 4) for (var k = 0; k \u003c a; k++) c[j + k \u003e\u003e\u003e 2] |= (e[k \u003e\u003e\u003e 2] \u003e\u003e\u003e 24 - 8 * (k % 4) \u0026 255) \u003c\u003c 24 - 8 * ((j + k) % 4); else if (65535 \u003c e.length) for (k = 0; k \u003c a; k += 4) c[j + k \u003e\u003e\u003e 2] = e[k \u003e\u003e\u003e 2]; else c.push.apply(c, e); this.sigBytes += a; return this }, clamp: function () { var a = this.words, c = this.sigBytes; a[c \u003e\u003e\u003e 2] \u0026= 4294967295 \u003c\u003c 32 - 8 * (c % 4); a.length = u.ceil(c / 4) }, clone: function () { var a = t.clone.call(this); a.words = this.words.slice(0); return a }, random: function (a) { for (var c = [], e = 0; e \u003c a; e += 4) c.push(4294967296 * u.random() | 0); return new r.init(c, a) } }), w = d.enc = {}, v = w.Hex = { stringify: function (a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j \u003c a; j++) { var k = c[j \u003e\u003e\u003e 2] \u003e\u003e\u003e 24 - 8 * (j % 4) \u0026 255; e.push((k \u003e\u003e\u003e 4).toString(16)); e.push((k \u0026 15).toString(16)) } return e.join(\"\") }, parse: function (a) { for (var c = a.length, e = [], j = 0; j \u003c c; j += 2) e[j \u003e\u003e\u003e 3] |= parseInt(a.substr(j, 2), 16) \u003c\u003c 24 - 4 * (j % 8); return new r.init(e, c / 2) } }, b = w.Latin1 = { stringify: function (a) { var c = a.words; a = a.sigBytes; for (var e = [], j = 0; j \u003c a; j++) e.push(String.fromCharCode(c[j \u003e\u003e\u003e 2] \u003e\u003e\u003e 24 - 8 * (j % 4) \u0026 255)); return e.join(\"\") }, parse: function (a) { for (var c = a.length, e = [], j = 0; j \u003c c; j++) e[j \u003e\u003e\u003e 2] |= (a.charCodeAt(j) \u0026 255) \u003c\u003c 24 - 8 * (j % 4); return new r.init(e, c) } }, x = w.Utf8 = { stringify: function (a) { try { return decodeURIComponent(escape(b.stringify(a))) } catch (c) { throw Error(\"Malformed UTF-8 data\") } }, parse: function (a) { return b.parse(unescape(encodeURIComponent(a))) } }, q = l.BufferedBlockAlgorithm = t.extend({ reset: function () { this.i0x = new r.init; this.yx9o = 0 }, zU9L: function (a) { \"string\" == typeof a \u0026\u0026 (a = x.parse(a)); this.i0x.concat(a); this.yx9o += a.sigBytes }, mU5Z: function (a) { var c = this.i0x, e = c.words, j = c.sigBytes, k = this.blockSize, b = j / (4 * k), b = a ? u.ceil(b) : u.max((b | 0) - this.WX9O, 0); a = b * k; j = u.min(","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:4:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#调试"},{"categories":null,"content":"分析 AES 加密 AES 加密集中在 b 方法 function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b), d = CryptoJS.enc.Utf8.parse(\"0102030405060708\"), e = CryptoJS.enc.Utf8.parse(a), f = CryptoJS.AES.encrypt(e, c, { iv: d, mode: CryptoJS.mode.CBC }); return f.toString() } 这个看起来还是比较好懂，主要是对各种加密方式的参数熟悉一些就可以发现了。 CryptoJS.enc.Utf8 就是将字符串按 UTF8 格式解码成字节数组 CryptoJS.AES.encrypt 是实际的加密方法，从上下文推断，第一个参数会传入原始的 params，所以第一个参数是原文，第二个参数是 key iv 是 AES 加密用到的 salt 返回的结果是 f.toString。我原本以为是返回 HEX 字符串，但观察正确的输出可以得知是 Base64 的 Mime 格式(末尾的 = 和 中间出现的 / 给了我们提示) \"fS15fDwPSPzRvd8OYwEnU2P/l/11+QKvMzWEy/EOn2RpIFXFYuDnEJrioOK25vaUCKckA2MPliSOq6gT5DtWQvEYq15QPvzphiPEUrd8Oj+UhTvOAfRE8v8gyrc8Ik5w6RyqosC3SqapEgPTagS0+l6yxhgwz8sWhL9yMn3SpgCJcnQ94YdKbxXVwpwXrO54HLHJSwzhKRECVsPU4rU+dvMbP2Z2x6HHUlOC3WYWdGkaj7h3PYivOKq3/yPgKyp9uExonxdn6aSAR46v5NSRk+6g+fqt9hR/UuKDXtKXVtbBGOFUbb/8Ns+m4Hj7k1Js\" 一切都是猜测，我们用 Java 代码模拟一下输出 public static String getAES(String input, String key, String salt) { AES aes = new AES(Mode.CBC, Padding.PKCS5Padding, key.getBytes(), salt.getBytes()); byte[] encrypt = aes.encrypt(input.getBytes()); return Base64.getMimeEncoder(Integer.MAX_VALUE, new byte[0]).encodeToString(encrypt); } public static void main() { String json = \"{\\\"hlpretag\\\":\\\"\u003cspan class=\\\\\\\"s-fc7\\\\\\\"\u003e\\\",\\\"hlposttag\\\":\\\"\u003c/span\u003e\\\",\\\"id\\\":\\\"19723756\\\",\\\"s\\\":\\\"daddydaddydo\\\",\\\"type\\\":\\\"1\\\",\\\"offset\\\":\\\"0\\\",\\\"total\\\":\\\"true\\\",\\\"limit\\\":\\\"30\\\",\\\"csrf_token\\\":\\\"\\\"}\"; String k3 = \"0CoJUm6Qyw8W8jud\"; String salt = \"0102030405060708\"; String res = getAES(json, , k3, salt); System.out.println(res); } 输出结果完美匹配。 其实这里还是有一点小插曲。AES 加密需要满足原文长度是一定的整数倍，如果不满足整数倍，就需要将原文填充。而填充的方式有很多种，常见的是用0填充。然而用0填充会发现最后的 Base64 在最后几个字符不匹配。在末尾不匹配，立马就应该想到是末尾填充的问题。所幸，填充的方式只有有限几种，穷举一下匹配就能得到结果了。正如代码里看到了，正确的填充方式选用了 PKCS5Padding。 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:5:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#分析-aes-加密"},{"categories":null,"content":"奇怪的 RSA 算法 RSA 算法的代码在 c 方法里 function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,\"\",c), e = encryptedString(d, a) } function encryptedString(a, b) { for (var f, g, h, i, j, k, l, c = new Array, d = b.length, e = 0; d \u003e e;) c[e] = b.charCodeAt(e), e++; for (; 0 != c.length % a.chunkSize;) c[e++] = 0; for (f = c.length, g = \"\", e = 0; f \u003e e; e += a.chunkSize) { for (j = new BigInt, h = 0, i = e; i \u003c e + a.chunkSize; ++h) j.digits[h] = c[i++], j.digits[h] += c[i++] \u003c\u003c 8; k = a.barrett.powMod(j, a.e), l = 16 == a.radix ? biToHex(k) : biToString(k, a.radix), g += l + \" \" } return g.substring(0, g.length - 1) } 简单分析下这两个方法，c 方法里生成了一个 KeyPair, 可以肯定，这个就是密钥。RSA的密钥由三个大数组成(n, p, q)，其中 (n, p), (n, q) 分别构成了公钥和私钥。在客户端加密中，一般是不出现私钥的，所以这里传了空。RSA 加密中 n 是一个很大的合数，由此可以确定 keyPair 三个参数的实际意义。 encryptedString 传入了密钥和明文进行加密。其中，明文是之前生成的随机数。 encryptedString 中对随机数依次取得 ascii 编码(第一个 for)，并将数组长度扩充到 chunkSize(第二个 for)。通过 debug 可以得知 chunkSize 的值是 126。 接下来的两个嵌套的 for 循环，将长度 126 的字节数组转换成了一个 BigInt。通过查看 BigInt 的相关代码可以得知，BigInt 的一个 int 数组，用来模拟一个 65536(0xFFFF) 进制的大整数。且所有以 bi 开头的函数，都是辅助这个 BigInt 类型进行大数计算的函数。 这里将随机数字符串转换成 BigInt 的逻辑，是将字符串每两个字符，一个作为高8位，一个作为低8位，构成 BigInt 的一个 65536 进制位，从低位开始填充(h++)。这显然不是一个常规方法。那其实就是一个以 ASCII 为基础的 65536 整数，每个字符表示 8 位。(HEX 是每个字符表示 4 位) 之后核心逻辑只剩下一个，powMod。powMod 也是 RSA 的核心计算，这里就显得十分直观了。根据 RSA 的原理 $$ 密文 = 原文^p \\mod n $$ 这里的 a.e 应该就是公钥了, j 是从字符串转成了 BigInt 的原文。根据公式计算出结果后，在取 Hex 字符串就好了 用 Java 代码验证 public static String getRSA(String input) { BigInteger k1 = new BigInteger(\"010001\", 16); BigInteger k2 = new BigInteger(\"00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7\", 16); BigInteger b = getB(input); BigInteger mod = b.modPow(k1, k2); return mod.toString(16); } public static BigInteger getB(String input) { BigInteger res = BigInteger.ZERO; for (int i = 0; i \u003c input.length(); i++) { int b = input.charAt(i); BigInteger bi = BigInteger.valueOf(b).shiftLeft(i * 8); res = res.or(bi); } return res; } public static void main() { String random = \"29MLTcVbKsvktpRV\" String res = getRSA(random); System.out.println(res); } 结果也是完美匹配。 中间当然也是有小插曲的。最初尝试的时候，使用标准的 RSA 库去实现。但是 RSA 是一个多次迭代且会加入随机值的加密算法。而网页接口里的 RSA 只使用了依次迭代就完成了加密，显然和标准的 RSA 还是有一点区别的。文中的代码，也是反复测试和分析代码才得出来的结果。 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:6:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#奇怪的-rsa-算法"},{"categories":null,"content":"尾声 至此，所有代码已经分析完成，一下展示完整的 Java 实现 public class Music { public static void main(String[] args) { String input = \"{\\\"hlpretag\\\":\\\"\u003cspan class=\\\\\\\"s-fc7\\\\\\\"\u003e\\\",\\\"hlposttag\\\":\\\"\u003c/span\u003e\\\",\\\"id\\\":\\\"19723756\\\",\\\"s\\\":\\\"daddydaddydo\\\",\\\"type\\\":\\\"1\\\",\\\"offset\\\":\\\"0\\\",\\\"total\\\":\\\"true\\\",\\\"limit\\\":\\\"30\\\",\\\"csrf_token\\\":\\\"\\\"}\"; String random = \"29MLTcVbKsvktpRV\" String aes = getAES(input, \"0CoJUm6Qyw8W8jud\", \"0102030405060708\"); String text = getAES(aes, random, \"0102030405060708\"); String rsa = getRSA(random); System.out.println(text); System.out.println(rsa); } public static String getAES(String input, String key, String salt) { AES aes = new AES(Mode.CBC, Padding.PKCS5Padding, key.getBytes(), salt.getBytes()); byte[] encrypt = aes.encrypt(input.getBytes()); return Base64.getMimeEncoder(Integer.MAX_VALUE, new byte[0]).encodeToString(encrypt); } public static String getRSA(String input) { // p BigInteger v1 = new BigInteger(\"010001\", 16); // n BigInteger v2 = new BigInteger(\"00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7\", 16); BigInteger b = getB(input); BigInteger mod = b.modPow(v1, v2); return mod.toString(16); } public static BigInteger getB(String input) { BigInteger res = BigInteger.ZERO; for (int i = 0; i \u003c input.length(); i++) { int b = input.charAt(i); BigInteger bi = BigInteger.valueOf(b).shiftLeft(i * 8); res = res.or(bi); } return res; } } 虽然我们提取了很多中间值，但其实关乎用户输入的只有真实请求 json 和随机数两项。接下来所有类似的接口都是这个加密方式，只需要再从网页是 debug，得到请求 json 的结构，就能发出正确的请求了 到此，网易云音乐 web 接口分析告一段落。 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:7:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#尾声"},{"categories":null,"content":"题外话 网易接口这种加密方式是比较有趣且常见的加密方式。使用到了 AES 和 RSA 加密方法结合。 RSA 是一种非对称加密，我们使用客户端公钥加密的数据，只可能使用服务端的私钥进行解密。但是，RSA 是基于大数计算的加密算法，效率较差。原文长度不能超过密钥中 n 的长度，即原文过长，则需要一个更大的合数参与模运算，势必降低加密性能。 而 AES 是一种对称加密方式，虽然性能提升了，但是不可避免地会将密钥泄露到客户端中。 因此，这里的解决方案是使用一个随机数作为 AES 的密钥将原文进行加密，然后将随机数使用 RSA 加密后传到服务端。由于随机数的长度是短且固定的，因此 RSA 也就不需要生成过长的密钥。服务端只需要用 RSA 私钥解密得到随机数后，用随机数进行 AES 解密即可得到原文。 这种 AES + RSA 的解决方案，是很常用的技巧，希望大家可以学以致用。 ","date":"2022-08-03","objectID":"/posts/crack/crack-163-music/:8:0","series":null,"tags":["逆向"],"title":"网易云接口逆向","uri":"/posts/crack/crack-163-music/#题外话"},{"categories":null,"content":"最近被反馈开发的接口出现跨域问题，本着“人类本质”的精神，不想独立部署一个跨域的前端去测试跨域问题。 想到可以通过控制台模拟跨域情景，果断动手操作 var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"http://localhost:9999/test\"); xhr.send(null); xhr.onload = function(e) { var xhr = e.target; console.log(xhr.responseText); } ","date":"2022-03-15","objectID":"/posts/test/cors-test/:0:0","series":null,"tags":["测试"],"title":"偷懒的Cors测试","uri":"/posts/test/cors-test/#"},{"categories":["MySQL"],"content":" MySQL 有一个大家都知道的坑点，就是 utf8 字符集并不是标准规范里的 utf8。对此，MySQL 给出了 utf8mb4 字符集对应标准的 utf8。 但是如果旧数据库已经使用上错误的 utf8 字符集，现在要进行切换就比较麻烦了。而 MySQL 是没有提供这样 DDL 的，所以有了批量修改字符集的需求。 ","date":"2021-12-22","objectID":"/posts/mysql/mysql-charset-reset/:0:0","series":null,"tags":["MySQL"],"title":"MySQL 批量修改字符集","uri":"/posts/mysql/mysql-charset-reset/#"},{"categories":["MySQL"],"content":"大致思路 读取表结构，给指定数据库生成 DDL 语句再批量执行。 修复过程大致上分为三步 修复字段 修复表 修复数据库 ","date":"2021-12-22","objectID":"/posts/mysql/mysql-charset-reset/:1:0","series":null,"tags":["MySQL"],"title":"MySQL 批量修改字符集","uri":"/posts/mysql/mysql-charset-reset/#大致思路"},{"categories":["MySQL"],"content":"修复表字段 MySQL 表结构都保存在 information_schema 这个库中。其中 COLUMNS 这张表保存了所有的表字段。 SELECT TABLE_SCHEMA '数据库', TABLE_NAME '表名', COLUMN_NAME '列名', CHARACTER_SET_NAME '字符集', COLLATION_NAME '排序规则', CONCAT('ALTER TABLE ', TABLE_SCHEMA,'.',TABLE_NAME, ' MODIFY COLUMN ',COLUMN_NAME, ' ', COLUMN_TYPE, ' COMMENT \"', COLUMN_COMMENT, '\" CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;') '修复语句' FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = '\u003cdatabase\u003e' AND TABLE_NAME = '\u003ctable\u003e' AND COLLATION_NAME RLIKE 'utf8'; 警告 这里的表备注一定不要去掉，不然表备注是会被清空的。 注意 \u003cdatabase\u003e 和 \u003ctable\u003e 填要修改的表和库名，限定修改范围。COLLATION_NAME 是原字符集，这里限定了只修改错误的 utf8 编码，如果修改全部字段编码，去掉这个过滤条件就好了。 最后把生成出来的修复语句拷贝出来，粘贴到你熟悉的工具批量执行，或者放到文本里作为 .sql 直接执行。 ","date":"2021-12-22","objectID":"/posts/mysql/mysql-charset-reset/:1:1","series":null,"tags":["MySQL"],"title":"MySQL 批量修改字符集","uri":"/posts/mysql/mysql-charset-reset/#修复表字段"},{"categories":["MySQL"],"content":"修复表 表的信息在 information_schema.TABLES 这张表 SELECT TABLE_SCHEMA '数据库', TABLE_NAME '表名', TABLE_COLLATION '原排序规则', CONCAT('ALTER TABLE ',TABLE_SCHEMA,'.', TABLE_NAME, 'COLLATE=utf8mb4_general_ci;') '修复语句' FROM information_schema.TABLES WHERE TABLE_COLLATION RLIKE 'utf8'; 同样把修复语句拷贝出来批量执行 ","date":"2021-12-22","objectID":"/posts/mysql/mysql-charset-reset/:1:2","series":null,"tags":["MySQL"],"title":"MySQL 批量修改字符集","uri":"/posts/mysql/mysql-charset-reset/#修复表"},{"categories":["MySQL"],"content":"修复数据库 数据库的信息在 information_schema.SCHEMATA 这张表 SELECT SCHEMA_NAME '数据库', DEFAULT_CHARACTER_SET_NAME '原字符集', DEFAULT_COLLATION_NAME '原排序规则', CONCAT('ALTER DATABASE ', SCHEMA_NAME, ' CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;') '修复语句' FROM information_schema.SCHEMATA WHERE DEFAULT_CHARACTER_SET_NAME RLIKE 'utf8'; ","date":"2021-12-22","objectID":"/posts/mysql/mysql-charset-reset/:1:3","series":null,"tags":["MySQL"],"title":"MySQL 批量修改字符集","uri":"/posts/mysql/mysql-charset-reset/#修复数据库"},{"categories":["Linux"],"content":" 最近在一个离线的电脑上要安装一个 fastdfs 做内网的文件服务器。fastdfs 又只提供了源码提供编译安装，于是要在一台我十分讨厌的 Centos 系统上做离线安装 gcc-c++, libevnet等一众依赖库支持编译。麻烦在于这些库的依赖也很多，一个个找依赖肯定是不可行的。就想着是不是可以通过 yum 导出所有的依赖。 ","date":"2021-12-21","objectID":"/posts/linux/centos-yum-offline-install/:0:0","series":null,"tags":["centos","yum","运维"],"title":"Centos 离线安装 yum 软件","uri":"/posts/linux/centos-yum-offline-install/#"},{"categories":["Linux"],"content":"yumdownloader yumdownloader 可以根据 yum 一样的依赖管理，把所需要的 rpm 包一并下载到本地，包括所有嵌套的依赖项。 那么只要找一台有网络的机器把所有依赖包下好，再在离线安装的机器上一键安装就好了。 ","date":"2021-12-21","objectID":"/posts/linux/centos-yum-offline-install/:1:0","series":null,"tags":["centos","yum","运维"],"title":"Centos 离线安装 yum 软件","uri":"/posts/linux/centos-yum-offline-install/#yumdownloader"},{"categories":["Linux"],"content":"安装 yumdownloader yum install -y yum-utils ","date":"2021-12-21","objectID":"/posts/linux/centos-yum-offline-install/:1:1","series":null,"tags":["centos","yum","运维"],"title":"Centos 离线安装 yum 软件","uri":"/posts/linux/centos-yum-offline-install/#安装-yumdownloader"},{"categories":["Linux"],"content":"下载所有依赖包 # 下载 gcc—c++,libevent 及其依赖 yumdownloader gcc-c++ libevent 注意 默认会将所有 rpm 包下载到当前目录，用 –destdir 参数指定下载目录 ","date":"2021-12-21","objectID":"/posts/linux/centos-yum-offline-install/:1:2","series":null,"tags":["centos","yum","运维"],"title":"Centos 离线安装 yum 软件","uri":"/posts/linux/centos-yum-offline-install/#下载所有依赖包"},{"categories":["Linux"],"content":"打包复制离线机器后安装 # 安装所有 rpm 包 rpm -Uvh *.rpm # 如果出现依赖缺失可以尝试关闭依赖分析 rpm -Uvh --nodeps *.rpm ","date":"2021-12-21","objectID":"/posts/linux/centos-yum-offline-install/:1:3","series":null,"tags":["centos","yum","运维"],"title":"Centos 离线安装 yum 软件","uri":"/posts/linux/centos-yum-offline-install/#打包复制离线机器后安装"}]